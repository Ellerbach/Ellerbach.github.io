# 2006-08-07 J'ai hacké mon onduleur ou le reverse engineering de protocoles de communication (part 2)

Cette fois-ci, je vais rentrer plus dans le concret des quelques étapes clés à suivre pour déchiffrer le fonctionnement d'un protocole de communication. Pour ceux qui veulent suivre la genèse de l'article, allez voir le [premier post](./2006-08-06-J'ai-hacké-mon-onduleur-ou-le-reverse-engineering-de-protocoles-de-communication-(part-1).md).

Je vais commencer par rappeler quelques principes de base quand on veut faire du reverse engineering. Loin de moi l'idée d'être exhaustif et de proposer une méthode infaillible et universelle. Ils sont juste basés sur le bon sens et des grands principes d'ingénierie. J'appliquerais ces principes sur mon exemple d'onduleur.

La première étape consiste à se munir des bons outils : la documentation complète du vecteur d'information, des outils d'écoutes, des outils d'analyse et des outils de simulation. Pour un port série, c'est assez simple. C'est un des premiers ports à être apparu sur les ordinateurs. De base, il ne nécessite que 3 fils de base: une masse, une ligne de donnée montante et une ligne de données descendante. Certains montages peuvent nécessités d'autres lignes qui permettaient notamment, au début, de faire du contrôle de données.

Alors pour commencer, qu'est-ce que RS232 ? Et bien, c'est une norme de communication série que l'on trouve RS232 à l'EIA/TIA et qui est identique aux normes CCITT V.24/V.28, X.20bis/X.21bis et ISO IS2110. Des mots bien compliqués pour l'appeler familièrement un « port série ». De bonnes explications en anglais sur [Wikipedia](https://en.wikipedia.org/wiki/Rs232). Pourquoi série ? Et bien tout simplement parce que les données sont transmises en série, les unes après les autres sur une seule ligne. La différence avec un port parallèle, c'est que sur le port parallèle, il faut un fil par bit (en général), et les données d'un mot sont transmises toutes en même temps. Le principe du port série est d'ailleurs réutilisé sur les ports SATA (contrôleurs de disques dur nouvel génération) qui remplace les ports PATA qui eux transmettaient les informations en parallèle. Le port USB est également un très bon exemple d'utilisation de transmission en série des informations. Chaque technologie présente ses avantages et ses inconvénients. Je ne rentrerais pas dans le détail ici car j'ai besoin d'espionner à un niveau plus haut dans les couches OSI que sur la couche de transport en tant que tel.

Le port série se présente sous la forme de prises DB25 (25 broches), DB9 (9 broches) ou RJ45 (8 broches). Les plus courants sont DB9 (on les trouve sur les PC actuels). Les DB25 ne sont plus utilisés depuis pas mal d'années et on évite les RJ45 pour ne pas les confondre avec les prises réseaux. Côté physique, les 3 seuls chiffres à retenir sur une DB9, ce sont 2, 3 et 5. 5 est la masse. La câblage de base consiste donc à relier 2 appareils en mettant directement les broches 2 et 3 en liaison (ou très rarement 2-2 et 3-3) et relier entre elles les broches 5. Dans mon cas, un câble série était livré, je n'ai pas eu besoin de me prendre la tête avec du câblage. Cependant, cela peut s'avérer utile d'avoir 2 câbles tout prêts, un droit et un croisé (appelé câble null modem) pour faire ce type de manipulation. Les autres broches peuvent avoir leur importance suivant ce que l'on cherche à faire. Mais elles ne sont pas obligatoires. Tous les câblages sont disponibles dans la [doc de Windows 2000](https://www.microsoft.com/windows2000/fr/advanced/help/sag_MODEconcepts_133.htm) par exemple.

Côté communication, le port série fonctionne avec :

* un débit données, exprimé en baud : (150), 300, (600), 1 200, 2 400, (3 600), 4 800, 9 600, 19 200, 28 400, 38 400, 57 600, 115 200, entre parenthèse les débits possibles mais plus utilisés ou rarement utilisés. Avec les nouveaux chpsets, il est possible d'obtenir une plage plus large notamment entre 28,4 et 57,6 K baud.
* un nombre de bit par mot 7 ou 8,
* une parité : None (aucune), Odd (paire), Even (Impaire), Mark (marquée)
* 1 ou 2 bits de stop
    Les informations sont codées du bit de point faible vers le bit de poids fort suivi du bit de parité (si pas none) et du ou des bits de stop. A priori, rien n'interdit les transmissions simultanées. Dans ce cas, il faut être sûr que les broches ready to send et ready do receive sont bien reliées les unes avec les autres.

Pour pouvoir correctement espionner ce qui circule sur le port série, la première difficulté consiste donc à trouver la bon paramétrage. Ce n'est pas si facile car les possibilités sont nombreuses. Dans mon cas, je ne possède pas la documentation du protocole de communication, impossible donc de connaître les bonnes informations. Et rien n'est écrit sur le matériel. Pas d'information disponible.

J'ai la « chance » d'avoir un logiciel qui communique déjà avec mon onduleur. La seule chose que je vais donc avoir besoin de faire, c'est de l'espionner pour obtenir ces informations. L'avantage d'être à ce niveau là, c'est que c'est du logiciel. Et comme on dit, en logiciel tout est possible . Donc, je pars m'équiper d'un outil d'écoute. J'en connais un très bien : [PortMon](https://www.sysinternals.com/Utilities/Portmon.html). Il provient de Sysinternals. Un site avec de nombreux outils tous indispensables au bon développeur et administrateur réseau. Sysinternals vient d'ailleurs d'être racheté par Microsoft il y a quelques semaines. Mark Russinovich et Bryce Cogswell ont toujours été pour moi des idoles et ils vont certainement le rester longtemps. Le fonctionnement de PortMon est parfaitement documenté sur le site.

PortMon permet d'écouter ce qui se passe sur un port série ou un port parallèle. Je lance donc PortMon, je paramètre l'utilisation du port pour l'ordinateur local et utilise le port COM1. Je lance ensuite l'outil de monitoring de l'onduleur et j'écoute. Et vous savez quoi ? Et bien, on trouve plein de choses intéressantes… La suite au prochain post.
